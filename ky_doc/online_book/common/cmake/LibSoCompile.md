# 静态库动态库和编译器

## 静态库
> 静态库（Static Library）是一种把一些函数或模块编译后，连成一个文件可以节省空间以及提高程序运行效率的库。
> 它以独立的文件形式存在，可以方便地被其它函数或程序使用，从而可以大大减少编程时间以及提高程序运行效率。

通俗的来说，静态库就是已经编码成了二进制，供给其他程序调用的一种文件格式
- 他会在链接的时候，直接拷贝到目标程序中
- 他的好处就是由于在同一个目标执行对象里，通常不存在依赖找不到的情况。
  - 由于已经编译好了，程序只要执行链接命令，在大程序中，会大大提高编译效率(动态库同理)
- 但是也会带来一个比较大的问题，如果其被A，B同时需要，也会直接拷贝到两个目标里，结果程序编译出来非常大

## 动态库
> 动态库，又称共享库，是一种可重用程序资源，可以被加载并有效地共享的一种库。
> 与静态库（Static Libraries）不同的是，动态库只有在真正需要时才会被加载，这样可以有效地减少了内存空间的占用，提升了系统整体的性能。

和静态库相比，动态库被链接的时候，只会把函数在内存中初始化的地址加入
- 这大大减少了编译时候，程序莫名臃肿的问题
- 但也会带来一个比较严重的问题
    - 程序编译的时候，加入的只是指针的内存信息
    - 程序执行的时候，首先要求系统读取这个动态库，每个系统的动态库搜索方式又不太一样
    - 导致好不容易编译成功了，程序无法跑起来
    - 这在有多个手动编译的cxx库，并且放的位置还千奇百怪的情况下，非常难以处理程序依赖问题
- 同时动态库还需要控制函数的导出问题，需要反汇编工具帮忙查看某个函数是不是被正常导出，或者找到对应的依赖(so调用另一个so的时候)

## 编译器如何链接库文件
> 编译的代码会有细节上的差异，但不会很大，[参考链接](https://blog.csdn.net/jokerMingge/article/details/129171899#:~:text=%E5%B0%86%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E9%93%BE%E6%8E%A5%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93%E6%96%87%E4%BB%B6%E3%80%82%20%E4%BD%BF%E7%94%A8%20g%2B%2B,%E5%91%BD%E4%BB%A4%E7%9A%84%20-shared%20%E9%80%89%E9%A1%B9%E5%8F%AF%E4%BB%A5%E5%B0%86%E5%A4%9A%E4%B8%AA%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E9%93%BE%E6%8E%A5%E6%88%90%E4%B8%80%E4%B8%AA%E5%8A%A8%E6%80%81%E5%BA%93%E6%96%87%E4%BB%B6%E3%80%82)

这两者的链接思路是一致的，并不存在很大的差距，通常步骤如下：
1. 指定库文件搜索路径
2. 告诉编译器需要链接的文件名称

```c++
g++ test.cpp -L搜索路径 -l文件名(通常不需要后缀，编译器自动判断)
```

cmake的链接会更加智能一些，通常会在指定的链接目录里搜索目标，
如果是符合cmake规范的包，还可以通过project名称进行链接
